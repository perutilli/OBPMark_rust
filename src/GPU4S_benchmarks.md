## Problems
* [ ] Fix correctness ndarray (especially float and double), for now against 2d matrix (it is the safest)
* [x] Do the same for 1d to sanity check the indexing
* [ ] Fix formatting problems for integers
* [ ] Why are integers not overflowing even without the modulo?
* [ ] Note that the random_seed gives the same result ONLY on the same machine
* [ ] Think of potential verification function where it takes the closures to execute to get the expected result, so that verification could be one line.
* [ ] Probably we want a trait for Matrix, so that we are sure that some functions have a certain signature, this is not strictly necessary since at compilation time we know which matrix type we are using (which is also good for performance), however it would be nice to have.

### Correctness checking
As (maybe) expected, the ndarray fails verification for float and double. However sometimes it does pass using epsilon of 1e-4 (same used in the original benchmark). Why does this happen?  
Also how come it is so fast -> Quite sure it uses BLAS or something similar, we need to be sure of this. 
<mark> I think we might want to abandon ndarray at least for the moment, it might not be mantained anymore. I do want to come back to it however </mark>

## General notes
<mark>Remember to use the `--release` flag when compiling the benchmarks if testing the performance!!!</mark>

Cargo features are not supposed to be used the way we are using them, however there does not seem to be a straight forward way to achieve the same functionality. The question is whether we care enough about the size of the binary to keep using conditional compilation (in this "wrong" way, we would enforce proper features values like so https://internals.rust-lang.org/t/mutually-exclusive-feature-flags/8601) or if we can just deal with this stuff with clap.  
I believe that we do care about the size of the binary, given that the code will run on embedded devices.

There exist blas and lapack ports to rust (https://github.com/stainless-steel/blas, https://github.com/stainless-steel/lapack), however they are autogenerated and all the calls are unsafe (which might not be fixable).  
While this is likely not a problem since this libraries have existed for decades, this might go against the idea of having a safe language, making them, in my opinion, not suitable for this benchmark.  
These are some probably more suitable alternatives:
* nalgebra: Linear algebra library (https://www.nalgebra.org/docs/)
* ndarray: provides an N-dimensional container for general elements and for numerics. (https://docs.rs/ndarray)
* rulinalg a linear algebra library written in Rust that doesnâ€™t require heavy external dependencies. (https://github.com/AtheMathmo/rulinalg/) -> apparently not maintained anymore 
 
Is this even the direction we want to go? I think we might want to implement this ourselves, in which case though we should probably have this be a separate library, so that the code is usable not exclusively for this benchmark.

How can I check correctness??

Our structure could be the following:

`lib.rs`
```rust
mod matrix_1d;
mod matrix_2d;
mod matrix_ndarray;

// error enum definition

trait MatMul {
    fn mat_mul(&self, other: &Self, res: &mut Self) -> Result<(), Error>;
}
```

`matrix_1d.rs`
```rust
pub struct Matrix {
    data: Vec<Number>,
    rows: usize,
    cols: usize,
}

impl MatMul for Matrix {
    fn mat_mul(&self, other: &Self, res: &mut Self) -> Result<(), Error> {
        // do stuff
    }
}
```

`matrix_2d.rs`
```rust
pub struct Matrix {
    data: Vec<Vec<Number>>,
    rows: usize,
    cols: usize,
}
```

`main.rs`
```rust
#[cfg(feature = "matrix_1d")]
use matrix_1d::Matrix;
#[cfg(feature = "matrix_2d")]
use matrix_2d::Matrix;
#[cfg(feature = "matrix_ndarray")]
use matrix_ndarray::Matrix;

```
I think it should check all the boxes:  
- [x] straight forward and localized conditional compilation
- [x] binary size should be the same as if we had a single implementation
- [x] completely transparent to the main function, it only has to use the `Matrix` type
- [x] each benchmark defines a new trait and implements it for the various matrix types